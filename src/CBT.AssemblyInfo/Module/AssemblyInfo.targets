<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0" >

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup Condition="'$(MSBuildTasksPath)'==''">
    <MSBuildTasksPath>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll</MSBuildTasksPath>
    <MSBuildTasksPath Condition="!Exists('$(MSBuildTasksPath)')">$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll</MSBuildTasksPath>
  </PropertyGroup>


  <PropertyGroup>
    <AssemblyInfoTemplateDirectory Condition="'$(AssemblyInfoTemplateDirectory)'==''">$(MSBuildThisFileDirectory)Template\Basic</AssemblyInfoTemplateDirectory>
    <AssemblyInfoOutputPath Condition="'$(AssemblyInfoOutputPath)'==''">$(BaseIntermediateOutputPath)gen\AssemblyInfo</AssemblyInfoOutputPath>
  </PropertyGroup>  

  <ItemGroup>
    <Clean Include="%(AssemblyInfoTemplateFiles.GeneratedFile)" Condition="'$(MSBuildNodeCount)' == '1'"/>
  </ItemGroup>  

  <UsingTask
    TaskName="AssemblyInfoWriteGeneratedFile"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildTasksPath)" >
    <ParameterGroup>
      <TemplateFileName Required="true" />
      <ResultFileName Required="true" />
      <Replacements ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
    </ParameterGroup>

    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Threading" />      
      <Code Type="Fragment" Language="cs">
<![CDATA[
// get a hash of the file path; reason: there's a limit on name length for named mutexes
string mutexName = ResultFileName.ToLowerInvariant().GetHashCode().ToString("X");

using (var mutex = new Mutex(false, mutexName))
{
    bool owner = false;
    try
    {
        try
        {
            owner = mutex.WaitOne(TimeSpan.FromMinutes(1)); // typically should be few ms; giving it 1 minute just in case
            if (!owner)
            {
                throw new TimeoutException("Timeout waiting for mutex");
            }
        }
        catch (AbandonedMutexException)
        {
            Log.LogWarning("Why did someone abandon the mutex?");
            owner = true; // now mine
        }

        if (File.Exists(ResultFileName) && File.GetLastWriteTime(ResultFileName) > File.GetLastWriteTime(TemplateFileName))
        {
            return true; // someone else took care of it
        }
        
        using (var sr = new StreamReader(TemplateFileName))
        {
            using (var sw = new StreamWriter(ResultFileName, false))
            {
                string line;
                while ( (line = sr.ReadLine()) != null)
                {
                    var modifiedLine = line;
                    foreach (var item in Replacements)
                    {
                      modifiedLine = modifiedLine.Replace(item.ItemSpec, item.GetMetadata("Value"));
                    }
                    sw.WriteLine(modifiedLine);
                }
            }
        }        
    }
    finally
    {
        if (owner)
        {
            mutex.ReleaseMutex();
        }
    }
}
]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="AssemblyInfoGenerateFile"
    Condition="'@(AssemblyInfoTemplateFiles)' != ''"
    BeforeTargets="$(AssemblyInfoRunBeforeTargets)"
    Inputs="%(AssemblyInfoTemplateFiles.Identity)"
    DependsOnTargets="$(AssemblyInfoGenerateFileDependsOn)"
    Outputs="%(AssemblyInfoTemplateFiles.GeneratedFile)" >
    <PropertyGroup>
      <AssemblyInfoGeneratedOutputPath>%(AssemblyInfoTemplateFiles.GeneratedFile)</AssemblyInfoGeneratedOutputPath>
      <AssemblyInfoGeneratedOutputPath>$([System.IO.Directory]::GetParent('$(AssemblyInfoGeneratedOutputPath)'))</AssemblyInfoGeneratedOutputPath>
    </PropertyGroup>
    <MakeDir Condition="!Exists($(AssemblyInfoGeneratedOutputPath))" Directories="$(AssemblyInfoGeneratedOutputPath)" />

    <Error Text="Couldn't find template file '%(AssemblyInfoTemplateFiles.Identity)'" Condition="!Exists('%(AssemblyInfoTemplateFiles.Identity)')" />
    
    <Message Text="Generating '%(AssemblyInfoTemplateFiles.GeneratedFile)' from '%(AssemblyInfoTemplateFiles.Identity)'" />

    <AssemblyInfoWriteGeneratedFile TemplateFileName="%(AssemblyInfoTemplateFiles.Identity)" ResultFileName="%(AssemblyInfoTemplateFiles.GeneratedFile)" Replacements="@(AssemblyInfoVars)" />
  </Target>

</Project>
