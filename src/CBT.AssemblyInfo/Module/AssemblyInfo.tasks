<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0" >
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup Condition="'$(MSBuildTasksPath)'==''">
    <MSBuildTasksPath>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll</MSBuildTasksPath>
    <MSBuildTasksPath Condition="!Exists('$(MSBuildTasksPath)')">$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll</MSBuildTasksPath>
  </PropertyGroup>

  <UsingTask
    TaskName="AssemblyInfoWriteGeneratedFile"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildTasksPath)" >
    <ParameterGroup>
      <TemplateFileName Required="true" />
      <ResultFileName Required="true" />
      <Replacements ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
    </ParameterGroup>

    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Threading" />      
      <Code Type="Fragment" Language="cs">
<![CDATA[
// get a hash of the file path; reason: there's a limit on name length for named mutexes
string mutexName = ResultFileName.ToLowerInvariant().GetHashCode().ToString("X");

using (var mutex = new Mutex(false, mutexName))
{
    bool owner = false;
    try
    {
        try
        {
            owner = mutex.WaitOne(TimeSpan.FromMinutes(1)); // typically should be few ms; giving it 1 minute just in case
            if (!owner)
            {
                throw new TimeoutException("Timeout waiting for mutex");
            }
        }
        catch (AbandonedMutexException)
        {
            Log.LogWarning("Why did someone abandon the mutex?");
            owner = true; // now mine
        }

        if (File.Exists(ResultFileName) && File.GetLastWriteTime(ResultFileName) > File.GetLastWriteTime(TemplateFileName))
        {
            return true; // someone else took care of it
        }
        
        using (var sr = new StreamReader(TemplateFileName))
        {
            using (var sw = new StreamWriter(ResultFileName, false))
            {
                string line;
                while ( (line = sr.ReadLine()) != null)
                {
                    var modifiedLine = line;
                    foreach (var item in Replacements)
                    {
                      modifiedLine = modifiedLine.Replace(item.ItemSpec, item.GetMetadata("Value"));
                    }
                    sw.WriteLine(modifiedLine);
                }
            }
        }        
    }
    finally
    {
        if (owner)
        {
            mutex.ReleaseMutex();
        }
    }
}
]]>
      </Code>
    </Task>
  </UsingTask>

</Project>